# Leader Dojo 架构设计文档 v0.5

> 目标：一套代码，支持 **Web + Mobile**，前后端逻辑清晰分层，并能在 **美国环境（US）** 与 **中国环境（CN）** 通过不同部署配置运行（双部署），核心业务逻辑与数据模型保持一致。

---

## 1. 架构目标与约束

### 1.1 业务目标

- 支持 Leader Dojo v0.5 功能：
    
    - Projects / Entries / Commitments / Reflections / Dashboard / Quick Capture
        
- 支持 **Web-first** 使用体验：桌面端为主，移动端浏览器可用；
    
- 为未来 Mobile App（React Native / 原生）预留标准 API；
    
- 为未来 Conversation Sparring / 对话教练模块预留扩展点。
    

### 1.2 技术目标

- 前后端分层清晰：
    
    - Web 前端（Next.js App Router）
        
    - API / 服务层（REST / Server Actions）
        
    - 数据访问层（ORM + Postgres）
        
    - AI 服务抽象层
        
- 一套代码，通过不同运行配置部署到 US / CN 两个环境：
    
    - US：可使用 Vercel / Fly + Neon / Supabase + OpenAI 等；
        
    - CN：可使用 阿里云 / 腾讯云 + RDS(Postgres) + 国内大模型（如通义、文心等）。
        

### 1.3 非功能性约束

- 初期单用户 / 小规模多用户，无需微服务架构；
    
- 开发效率优先，架构需简单但不封死扩展路径；
    
- 对网络抖动与跨境访问敏感，因此 **不考虑单实例跨境访问**，而是 US/CN 各一套部署。
    

---

## 2. 总体架构概览

### 2.1 分层视图

整体采用「**前后端分离 + BFF（Backend For Frontend）** + 数据/AI 服务」的分层思路。

从上到下划分为四层：

1. **客户端层（Client Layer）**
    
    - Web 前端（Next.js React UI）
        
    - 移动端 App（未来：React Native / 原生）
        
2. **BFF / API 层（Application Service Layer / API）**
    
    - 为 Web 和 Mobile 提供统一的 JSON API
        
    - 也可在 Web 内部通过 Server Actions 直调服务函数
        
3. **领域服务与数据访问层（Domain Services & DAL）**
    
    - 领域服务（projectsService / entriesService / commitmentsService / reflectionsService / dashboardService ...）
        
    - 数据访问（Repositories + ORM + Postgres）
        
4. **基础设施层（Infrastructure Layer）**
    
    - 认证（Auth.js / NextAuth + Users/Accounts）
        
    - 数据库（Postgres：US/CN 不同实例）
        
    - AI 服务（aiClient：US 用 OpenAI，CN 用国内模型）
        
    - 日志监控（console + APM/Sentry 可选）
        

### 2.2 部署视图（US / CN 双部署）

**US 部署环境示例：**

- 前端 / BFF：
    
    - Vercel 部署 Next.js 单体应用（包含 API Routes / Server Actions）
        
- 数据库：
    
    - Neon / Supabase Postgres
        
- AI：
    
    - OpenAI / Anthropic，通过 `aiClient` 封装
        
- Auth Provider：
    
    - Email + Password / Magic Link
        
    - Google OAuth
        

**CN 部署环境示例：**

- 前端 / BFF：
    
    - 阿里云 ECS / 函数计算 / K8s 部署 Node.js 版 Next.js 应用
        
- 数据库：
    
    - 阿里云 RDS(Postgres) / PolarDB for PG
        
- AI：
    
    - 国内大模型（如阿里通义千问 / 百度文心 / 智谱），在 `aiClient` 中换实现
        
- Auth Provider：
    
    - 手机号 + 短信验证码
        
    - 微信 OAuth（后续）
        

> 两个环境共用同一代码仓库，使用不同的 **环境变量配置** 与 **Provider 实现**。

---

## 3. 客户端架构（Web & Mobile）

### 3.1 Web 前端（Next.js App Router）

**技术栈：**

- Next.js (App Router) + React + TypeScript
    
- UI 库：Tailwind CSS + （可选）shadcn/ui
    

**主要路由：**

- `/dashboard`：总览（Weekly Focus、Idle Projects、反思入口）
    
- `/projects`：项目列表
    
- `/projects/[id]`：项目详情（Snapshot + Timeline + Commitments Panel + Prep）
    
- `/commitments`：承诺列表（I Owe / Waiting For）
    
- `/reflections`：反思列表 + 创建反思
    
- `/capture`：Quick Capture 移动优先页面
    
- `/auth/*`：登录 / 注册 / Provider 回调等
    

**前端数据获取模式：**

两种模式并存：

1. **Server Components + Server Actions（SSR 优先）**
    
    - 页面加载时通过 Server Component + Server Action 从服务层获取数据：
        
        - `getDashboardData()` / `getProjectDetail(id)` / `getCommitments(filters)`
            
    - 突出利：简化数据 fetching 逻辑，前后端共享类型。
        
2. **API 调用（CSR / 未来 Mobile 复用）**
    
    - 将核心业务逻辑也暴露为 RESTful/JSON API：
        
        - `GET /api/dashboard`
            
        - `GET /api/projects/:id`
            
        - `POST /api/entries`
            
        - `POST /api/entries/:id/summarize`
            
        - `POST /api/commitments`
            
    - Web 端可在某些需要更强交互/局部刷新的地方用 fetch / SWR 调用 API。
        

**前端状态管理：**

- 以页面/组件内局部状态为主；
    
- 可以使用 React Query/SWR 做简单缓存，但不必重度使用全局 store；
    
- 所有持久化数据由后端负责，不在前端做复杂缓存持久化。
    

### 3.2 移动端架构规划

v0.5 阶段：

- 不开发独立原生 App，仅支持移动 Web：
    
    - `/capture` 页面采用移动优先设计（大号按钮、单列布局）；
        
    - `/projects/[id]` 重要视图适配小屏；
        

v0.6+ 阶段 Mobile 方案预案：

**选项 A：React Native / Expo App**

- 使用 React Native 写 iOS/Android 原生 App；
    
- 通过请求同一套 REST API：
    
    - 登录：`/api/auth/login`（下文 Auth 小节详细说明）
        
    - Dashboard：`/api/dashboard`
        
    - Projects / Entries / Commitments CRUD。
        
- 可按需内嵌 WebView 打开部分复杂页面（例如富文本、反思编辑）。
    

**选项 B：壳 + WebView 混合**

- 使用 Capacitor / Tauri / 原生壳加载 PWA；
    
- 让 `/dashboard`、`/projects`、`/capture` 直接在 WebView 中跑；
    
- 只针对需要系统能力（通知、语音录制等）的功能做少量桥接。
    

> 无论选 A 还是 B，关键是：**后端通过统一 API 暴露服务**，Web 与 Mobile 都视后端为 "single source of truth"。

---

## 4. BFF / API 层设计

### 4.1 API 风格

- 使用 RESTful JSON API 为 Web/Mobile 提供服务；
    
- 同时在 Next.js 中利用 API Routes / Route Handlers 实现这些 API；
    
- Server Actions 可调用同一套服务函数（避免双重实现）。
    

**命名约定：**

- 所有受保护路由以 `/api/secure/*` 开头，统一做鉴权；
    
- 对应资源命名如下：
    
    - `/api/secure/dashboard`
        
    - `/api/secure/projects`
        
    - `/api/secure/projects/:id`
        
    - `/api/secure/projects/:id/entries`
        
    - `/api/secure/entries/:id/summarize`
        
    - `/api/secure/commitments`
        
    - `/api/secure/reflections`
        

### 4.2 典型 API 定义（示例）

1. 获取 Dashboard 数据：
    

```http
GET /api/secure/dashboard
Authorization: Bearer <token>
```

响应（示例）：

```json
{
  "weeklyFocus": [
    { "id": "c1", "title": "Send intro email to X", "projectId": "p1", "dueDate": "2025-11-22" }
  ],
  "idleProjects": [
    { "id": "p2", "name": "Startup B", "lastActiveAt": "2025-09-10" }
  ],
  "pendingReviews": {
    "decisions": 2,
    "reflections": 1
  }
}
```

2. 创建 Entry：
    

```http
POST /api/secure/projects/:projectId/entries
Content-Type: application/json

{
  "kind": "meeting",
  "occurredAt": "2025-11-20T10:00:00Z",
  "title": "Q4 Check-in",
  "rawContent": "...meeting notes or transcript..."
}
```

3. 对 Entry 进行 AI 摘要和承诺建议：
    

```http
POST /api/secure/entries/:entryId/summarize
```

响应：

```json
{
  "summary": "...",
  "suggestedActions": [
    { "direction": "i_owe", "text": "Send follow-up deck", "counterpartySuggested": "Founder A" },
    { "direction": "waiting_for", "text": "Await product metrics", "counterpartySuggested": "CTO" }
  ]
}
```

4. 创建 Commitment：
    

```http
POST /api/secure/commitments

{
  "title": "Send follow-up deck",
  "projectId": "p1",
  "sourceEntryId": "e1",
  "direction": "i_owe",
  "counterparty": "Founder A",
  "dueDate": "2025-11-25",
  "importance": "high"
}
```

> 前端 Web 与未来 Mobile 都通过这套 JSON API 交互，保证多端一致性。

---

## 5. 领域服务与数据访问层

### 5.1 分层结构

推荐目录结构示例：

```txt
src/
  app/                # Next.js 路由
  api/                # (可选) 独立 API 目录或在 app/api 下
  lib/
    services/         # 领域服务 (业务逻辑)
      projectsService.ts
      entriesService.ts
      commitmentsService.ts
      reflectionsService.ts
      dashboardService.ts
    repositories/     # 数据访问
      projectsRepo.ts
      entriesRepo.ts
      commitmentsRepo.ts
      reflectionsRepo.ts
    db/
      schema.ts       # Drizzle/Prisma schema
      client.ts       # DB client 初始化
    ai/
      aiClient.ts     # AI 客户端抽象
    auth/
      authConfig.ts   # Auth.js 配置
```

### 5.2 领域服务职责

- `projectsService`：
    
    - 创建/更新 Project
        
    - 获取项目列表 / 详情
        
    - 维护 `lastActiveAt` 字段
        
- `entriesService`：
    
    - 创建 Entry
        
    - 获取项目 Entry 时间线
        
    - 标记决策 / 设置复盘时间
        
- `commitmentsService`：
    
    - 从 Entry 建议创建 Commitments
        
    - 查询 I Owe / Waiting For 列表
        
    - 更新状态、延期
        
- `dashboardService`：
    
    - 计算 Weekly Focus（基于承诺权重）
        
    - 查找 Idle Projects（基于 lastActiveAt + priority）
        
    - 汇总待复盘决策与反思
        
- `reflectionsService`：
    
    - 根据最近行为生成反思问题（调用 aiClient）
        
    - 保存反思记录
        

领域服务内部通过 `repositories` 与 DB 交互，前端和 API 层不直接写 SQL。

### 5.3 数据访问层（Repositories）

#### 5.3.1 ORM 技术选型约定

- **必须有独立的 Repository 层**，业务代码（services / API / 页面）一律通过 Repo 访问数据库，避免在组件或路由中直接写 SQL。
    
- ORM 选型优先级：
    
    - 推荐：**Drizzle ORM**（轻量、TS 友好、贴近 SQL、对 Postgres/pgvector 支持较好）；
        
    - 可选：**Prisma**（如团队已有经验或现成脚手架，可直接使用）；
        
    - 不推荐：完全手写 SQL 直连（除非在 ORM 中以 `queryRaw/execute` 方式少量补充特殊查询）。
        
- 架构层强调：**ORM 是实现细节，可替换**，关键是 `repositories/*` 层的边界清晰，保证未来可在不动业务逻辑的前提下更换 ORM 或迁移数据库。
    

#### 5.3.2 Repository 职责

使用 ORM（Drizzle / Prisma）定义数据模型：

- `projects` / `project_entries` / `commitments` / `reflections` 四张表，结构与 PRD 对应；
    
- repository 函数示例：
    
    - `findProjectsByUser(userId)`
        
    - `findEntriesByProject(projectId, limit, offset)`
        
    - `findOpenCommitments(userId, filters)`
        
    - `updateProjectLastActiveAt(projectId, occurredAt)`
        

> US / CN 环境仅在 `db/client.ts` 中的连接串与云服务不同，其余逻辑保持一致。

---

## 6. 认证与用户模型（Auth）

### 6.1 用户与身份（identity）建模

采用 Auth.js（NextAuth）推荐模型，一般包含：

- `users` 表：
    
    - `id` (uuid)
        
    - `name` / `email` / `createdAt` 等
        
- `accounts` 表（等价于 user_identities）：
    
    - `id`
        
    - `userId`
        
    - `provider` ("email_password" | "google" | "phone_sms" | "wechat" ...)
        
    - `providerAccountId`（如 Google sub / phone / openid）
        
    - `accessToken` / `refreshToken` / `expiresAt`（可选）
        
- `sessions` 表：
    
    - `id`
        
    - `userId`
        
    - `sessionToken`
        
    - `expires`
        

> 一个 user 可以有多条 account，对应不同登录方式。

### 6.2 US / CN 不同 Provider 策略

**US 环境：**

- 启用 Provider：
    
    - Email + Password / Email Link（Credentials / Email Provider）
        
    - Google OAuth（GoogleProvider）
        

**CN 环境：**

- 启用 Provider：
    
    - `phone_sms`：自定义 Credentials Provider，实现手机号 + 短信验证码登录
        
    - `wechat`：自定义 OAuth Provider，对接微信开放平台
        

**前端登录页面根据环境选择展示：**

- US 登录页面：
    
    - [Continue with Google]
        
    - or Email 登录
        
- CN 登录页面：
    
    - 手机号 + 验证码表单
        
    - （可选）[微信登录] 按钮
        

**共享逻辑：**

- 登录成功后都创建 `session` 并下发 Token（Cookie-based 或 Bearer Token）；
    
- 所有受保护 API 均通过中间件校验 session / token，得到 `userId`。
    

---

## 7. AI 服务抽象设计

### 7.1 抽象接口

定义统一 AI 客户端接口，例如：

```ts
// lib/ai/aiClient.ts
export interface AiClient {
  summarizeMeeting(input: {
    rawContent: string
    projectContext?: string
  }): Promise<{ summary: string; suggestedActions: SuggestedAction[] }>

  generateReflectionQuestions(input: {
    stats: any
  }): Promise<string[]>

  generatePrepBriefing(input: {
    entries: any[]
    commitments: any[]
  }): Promise<{ briefing: string }>
}

export type SuggestedAction = {
  direction: 'i_owe' | 'waiting_for'
  text: string
  counterpartySuggested?: string
}
```

在运行时，通过 `process.env.APP_REGION` / `AI_PROVIDER` 等环境变量选择具体实现：

```ts
// lib/ai/index.ts
import { OpenAiClient } from './openAiClient'
import { CnModelClient } from './cnModelClient'

export const aiClient: AiClient =
  process.env.APP_REGION === 'cn'
    ? new CnModelClient()
    : new OpenAiClient()
```

### 7.2 US 环境实现

- `OpenAiClient` 使用 OpenAI / Anthropic 官方 SDK 或 fetch API 调用：
    
    - 模型：GPT-4.x / Claude x
        
    - 按功能封装 prompt 模板：
        
        - 摘要 + 承诺建议
            
        - 反思问题生成
            
        - 会前 Briefing
            

### 7.3 CN 环境实现

- `CnModelClient` 调用国内大模型：
    
    - 通义千问 / 文心一言 / 智谱 / 自建模型
        
    - 使用兼容 JSON 输出的 prompt 模板
        

> 领域服务层只关心 `aiClient` 的接口返回，不关心具体模型供应商。

---

## 8. 部署与环境配置

### 8.1 环境变量策略

关键环境变量示例：

```env
APP_REGION=us | cn
DATABASE_URL=...
AI_PROVIDER=openai | cn_model
NEXTAUTH_URL=https://app.joinleaderdojo.com
NEXTAUTH_SECRET=...
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...
SMS_PROVIDER_API_KEY=...
WECHAT_APP_ID=...
WECHAT_APP_SECRET=...
```

- US 环境：
    
    - `APP_REGION=us`
        
    - `AI_PROVIDER=openai`
        
    - 配置 Google Client ID/Secret
        
- CN 环境：
    
    - `APP_REGION=cn`
        
    - `AI_PROVIDER=cn_model`
        
    - 配置短信网关 & 微信开放平台参数
        

### 8.2 部署方式

**US:**

- Vercel：
    
    - 使用 `next build` + Vercel serverless 进行部署
        
    - API Routes / Server Actions 自动跑在 Vercel Functions 上
        
- 数据库（Neon / Supabase）：
    
    - 独立托管，连接通过 `DATABASE_URL`
        

**CN:**

- 阿里云 ECS / 函数计算：
    
    - 使用 Docker 镜像：
        
        - `Dockerfile` 中执行 `next build` → `next start`
            
        - 通过 Nginx / SLB 暴露 HTTP 服务
            
- 数据库（阿里云 RDS）：
    
    - 在内网 VPC 内进行连接，避免跨公网访问
        

> 两个环境的 build 脚本与代码相同，只是 CI/CD pipeline 使用不同的云目标。

---

## 9. 安全、日志与监控

### 9.1 安全

- 所有 `/api/secure/*` 路由必须校验 session / token；
    
- CSRF：
    
    - 使用 Auth.js 内置 CSRF 防护；
        
- HTTPS：
    
    - US：通过 Vercel 自动启用 HTTPS
        
    - CN：通过阿里云/腾讯云证书 + 负载均衡配置 HTTPS
        

### 9.2 日志与监控

- 基础：
    
    - 应用日志输出到 stdout（由云平台采集）；
        
- 可选引入：
    
    - Sentry：错误追踪（US 起步，CN 视情况选用自建/国产替代）；
        
    - 简单访问日志 + 慢查询日志（Postgres）。
        

---

## 10. 未来扩展点：Sparring / Dojo Mode / Team 版

### 10.1 Sparring / Conversation Coach

在当前架构上新增：

- 表：`sparring_sessions` / `sparring_turns`
    
- API：
    
    - `POST /api/secure/projects/:id/sparring-sessions`
        
    - `POST /api/secure/sparring-sessions/:id/messages`
        
- AI：
    
    - 在 `aiClient` 中新增：
        
        - `simulateConversation(context, scenarioConfig)`
            
    - 生成的对话记录最终写入 `project_entries(kind='sparring')`。
        

### 10.2 Team 版 / 多用户协作

在保持现有表结构的前提下：

- 新增：
    
    - `workspaces` 表
        
    - `workspace_members` 表
        
- 为 Projects / Entries / Commitments 增加 `workspaceId` 字段；
    
- Auth 层：
    
    - 登录后确定当前 workspace 上下文
        
    - API 层按 workspace 做数据隔离。
        

---

## 11. RAG 与知识图谱（KG）扩展设计（v0.6+）

> 本节为架构预留 RAG + KG 的扩展能力，**v0.5 不强依赖**，但为 v0.6+ 功能（更聪明 Prep、深度反思、Sparring 场景推荐等）打基础。

### 11.1 数据扩展：向量表（RAG）

在现有 Postgres 基础上启用 `pgvector` 扩展，新增一张向量表：

```sql
CREATE TABLE project_entry_embeddings (
  id UUID PRIMARY KEY,
  entry_id UUID NOT NULL REFERENCES project_entries(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  kind TEXT NOT NULL,          -- meeting / self_note / decision / update / sparring 等
  occurred_at TIMESTAMPTZ NOT NULL,
  embedding VECTOR(1536) NOT NULL,  -- 维度根据所选 embedding 模型调整
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_project_entry_embeddings_user ON project_entry_embeddings(user_id);
CREATE INDEX idx_project_entry_embeddings_project ON project_entry_embeddings(project_id);
```

**嵌入生成策略：**

- 在创建或更新 `project_entries` 时：
    
    - 将 `raw_content + ai_summary` 拼接生成 embedding；
        
    - 写入 `project_entry_embeddings`；
        
- v0.5 可先用同步生成，数据量小；v0.6+ 可引入后台任务异步生成。
    

**RAG 检索能力封装：**

在 `lib/services/ragService.ts` 里封装检索函数：

```ts
retrieveRelevantEntries(query: string, options: {
  userId: string
  projectId?: string
  limit?: number
}): Promise<ProjectEntry[]>;
```

内部流程：

1. 先对 `query` 做 embedding；
    
2. 在 `project_entry_embeddings` 上按 `userId`（可选 `projectId`）做向量相似度检索；
    
3. 返回对应的 `project_entries` 记录列表。
    

### 11.2 数据扩展：轻量知识图谱（KG）建模

不必一开始上专门的图数据库，可在现有关系型 schema 基础上加几张“图谱关系表”，实现 **实体 + 关系**：

#### 11.2.1 `persons`（可在 v0.6 引入）

```sql
CREATE TABLE persons (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  role TEXT,              -- founder / cto / cofounder / lp / etc.
  org TEXT,               -- 所属公司/机构
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_persons_user ON persons(user_id);
```

#### 11.2.2 关系表：`person_project_links`

```sql
CREATE TABLE person_project_links (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  person_id UUID NOT NULL REFERENCES persons(id) ON DELETE CASCADE,
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  relation_type TEXT NOT NULL,  -- founder / stakeholder / investor / advisor / etc.
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_ppl_user ON person_project_links(user_id);
CREATE INDEX idx_ppl_person ON person_project_links(person_id);
CREATE INDEX idx_ppl_project ON person_project_links(project_id);
```

#### 11.2.3 主题建模：`topics` 与 `entry_topics`

```sql
CREATE TABLE topics (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,      -- cash runway / hiring / roadmap / conflict / etc.
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE entry_topics (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  entry_id UUID NOT NULL REFERENCES project_entries(id) ON DELETE CASCADE,
  topic_id UUID NOT NULL REFERENCES topics(id) ON DELETE CASCADE,
  confidence NUMERIC,      -- 0-1 置信度
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_entry_topics_entry ON entry_topics(entry_id);
CREATE INDEX idx_entry_topics_topic ON entry_topics(topic_id);
```

> 说明：上述几张表构成一个轻量级的“知识图谱”：
> 
> - 实体：User / Project / Person / Topic / Entry / Commitment / Decision
>     
> - 关系：Person–Project、Entry–Topic、Commitment–Person 等  
>     后续可用 SQL + 简单统计即可做出很多 "graph-powered" 视图，无须立刻引入 Neo4j 等专用图库。
>     

### 11.3 RAG + KG 驱动的高价值场景（v0.6+）

#### 11.3.1 RAG 增强的会前 Prep

- 接口：`generatePrepBriefing(projectId, options)`：
    
    - 基础：最近 N 条 entries + 未完成 commitments；
        
    - 增强：
        
        - 若用户输入本次会议主题（如 "cash runway"），
            
        - 使用 `retrieveRelevantEntries` 在当前 Project 的 entries 中按主题向量检索，
            
        - 并用 `entry_topics` 中标注为相关 Topic 的条目加权，
            
        - 选出 10–20 条最相关的 Entry 作为 briefing context；
            
    - 再调用 `aiClient.generatePrepBriefing` 生成更贴合本次议题的 Prep 卡片。
        

**效果：** 会前 Prep 不再只是 "最近几次更新"，而是围绕本次议题的历史战况总结。

#### 11.3.2 基于战史的深度反思问题

- 接口：`generateReflectionQuestionsWithContext(userId, period)`：
    
    - 先获取该周期内的关键统计（已在 v0.5 中有基础统计）；
        
    - 使用 RAG 在该周期 + 少量历史数据中检索：
        
        - 冲突 / 担忧类 Self Notes
            
        - 重大决策 entries
            
        - 反复延迟的 commitments 所在的 entries；
            
    - 结合这些具体片段（作为 context）调用 `aiClient.generateReflectionQuestions`；
        

**效果：** 反思问题变得高度个性化，例如：

- “你在与 Founder A 的三次对话中都写到『alignment 问题』，但从未制定具体承诺，你认为为什么？”
    
- “你在三家不同公司都对『执行力』感到担忧，这反映的是对方的问题，还是你的期望表达方式？”
    

#### 11.3.3 关系与结构风险雷达（基于 KG）

- 利用 `persons` + `person_project_links` + `commitments`：
    
    - 计算：每个 Person 关联的高优先级项目数、未完成承诺数、负面 Self Notes 频率；
        
    - 识别：
        
        - 高集中度 + 高风险 Person（单点故障）；
            
        - 关系持续紧张的合作对象（反复出现 conflict/hard talk topic）。
            
- Dashboard 新增区块：
    
    - “Relationship Risk Radar”：列出 Top N 风险关系结点，和建议下一步动作。
        

#### 11.3.4 主题级人生主线 & 模式洞察

- 基于 `topics` + `entry_topics`：
    
    - 展示：不同 Topic 在时间轴上的活跃度（出现频次、相关 Self Notes 情绪）；
        
    - 结合反思 & 决策结果，分析：
        
        - 你在哪些主题上长期停留在抱怨 / 观察阶段，而缺少决策与承诺；
            
        - 哪些主题已经形成正向 flywheel（决策 → 承诺 → 执行 → 正面反思）。
            

**效果：** Leader Dojo 不再仅是 “项目笔记本”，而是你的 **认知 / 领导力议题地图**。

### 11.4 实施节奏建议

**v0.5：**

- 只做 schema 预留：
    
    - `project_entry_embeddings`
        
    - `persons` / `person_project_links` / `topics` / `entry_topics`（可只建表，不强依赖）
        
- 在服务层预留函数签名：
    
    - `retrieveRelevantEntries`
        
    - `generatePrepBriefing`（内部暂用简单规则）
        
    - `generateReflectionQuestions`（暂不使用 RAG）
        

**v0.6：**

- 开启 embedding 填充流程（同步或异步）；
    
- 在会前 Prep 中使用 RAG；
    
- 在反思中引入基于 RAG + 统计的深度问题；
    
- 初步实现 Relationship Risk Radar（基于 SQL 统计 + 简单图逻辑）。
    

**v0.7+：**

- 全面引入 Person/Topic 视图，
    
- 实现基于 graph 的场景推荐（例如 Sparring 场景推荐、关键关系修复建议）。
    

---

## 12. 小结

- 架构核心是：**Web-first 的 Next.js 单体应用 + 清晰的服务层 + Postgres + AI Client 抽象**；
    
- 前后端通过 API/Server Actions 分离，未来 Mobile 可以直接复用 API；
    
- Auth 使用 Auth.js 提供统一的 users/accounts/sessions 模型，在 US 与 CN 环境配置不同的 Provider（Google vs SMS/WeChat）；
    
- AI 调用通过 `aiClient` 抽象，在 US 使用 OpenAI，在 CN 使用国产模型，实现“同一业务，不同底层”的双部署；
    
- 部署方面，US 可以用 Vercel + 托管 Postgres，CN 可以用阿里云 ECS + RDS，两边共用同一套代码与 schema，只通过 env 与 provider 实现差异化。
    

这份架构设计文档可作为 Leader Dojo v0.5 的工程落地蓝图，并为未来 Mobile App、Conversation Coach 模块以及团队版扩展预留足够空间。